# 简单编写vue3的弹窗插件

今天我们来在Vue3里面实现一个简单的弹窗插件。

## 1. 创建插件模板组件

下面是`alert.vue` 文件

```vue
<template>
  <div class="dialogs" v-if="visible">
    <div class="container">
        <div class="close" @click="visible = false">X</div>
      <p>这是一个全局的弹窗组件</p>
      <button>{{message}}</button>
    </div>
  </div>
</template>

<script lang="ts" setup>
import { ref } from 'vue';

defineProps({
  message: {
    type: String,
    default: () => "登录成功",
  },
});

const visible = ref(true);

</script>
<style scoped lang="scss">
.dialogs {
  width: 100%;
  height: 100%;
  position: absolute;
  left: 0;
  top: 0;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;

  .container {
    position: relative;
    background-color: #fff;
    border-radius: 10px;
    padding: 30px;

    .close {
        position: absolute;
        right: 10px;
        top: 10px;
        cursor: pointer;
    }
  }
}
</style>

```

## 2. 编写 plugins 并注册

我们在 `plugins` 文件夹下面编写 `alert.ts`

按照`Vue3`的写法如下 在全局注册要用到 `app.config.globalProperties` 而不是 `Vue2` 中直接放在 `Vue.prototype` 上面

```ts
import { App, h, render } from "vue"
import Alert from './index.vue'

export default {
    
    install(app: App) {

        app.config.globalProperties.$alert = (message: string) => {
            
            //1.调用h 函数把组件变虚拟dom VNode
            const VNode = h(Alert, {message});
            //2.准备挂载节点
            const container = document.createElement('div');
            //渲染到app节点下面
            document.getElementById("app")?.appendChild(container);
            //3.渲染虚拟dom 节点到真实 dom
            render(VNode, container);
        }
    }
}
```
接下来在`main.ts`中注册插件

```ts
import { createApp } from 'vue'
import App from './App.vue'
import router from './router/index';
import ElementPlus from "element-plus";
import 'element-plus/dist/index.css';
import Alert from './components/Alert/index';
//注册插件
createApp(App).use(ElementPlus).use(Alert).use(router).mount('#app')
```
## 3. 使用 `Alert` 插件

在任意一个页面即可测试

```vue
<template>
  <div v-if="loggin">Weclome {{user.username}}</div>
  <div v-if="!loggin">please login</div>
  <button @click="test">Test</button>
</template>

<script lang='ts' setup>
import { useUser } from '../composables/useUser';
import { ComponentInternalInstance, getCurrentInstance } from 'vue';

const { proxy } = getCurrentInstance() as ComponentInternalInstance;
const test = () => {
  proxy && (proxy as any).$alert("dsdds")
}
const { user, loggin } = useUser();

</script>
```
启动服务 测试一下 成功弹出

![](/v3/1.png)

## 4. 优化

### 使用第三方插件组件

但是如果我们在 `dialog.vue` 中引入第三方组件呢？下面我们引入`element-plus` 的 `button` 修改一下之前文件

```vue
<template>
  <div class="dialogs" v-if="visible">
    <div class="container">
        <div class="close" @click="visible = false">X</div>
      <p>这是一个全局的弹窗组件</p>
      <el-button type="primary">{{ message }}</el-button>
    </div>
  </div>
</template>
```
打开页面

![](/v3/2.png)

`el-button` 组件没有渲染！！

::: tip 
经过查阅资料，我们插件注册的时候上下文是独立的，所以无法引用到`element`的组件。
:::

所以我们接下来需要修改一下 插件的方法。将虚拟`dom`节点的上下文关联到 `app` 上面，使得可以使用其他组件

```ts
import { App, h, render } from "vue"
import Alert from './index.vue';

export default {
    
    install(app: App) {

        app.config.globalProperties.$alert = (message: string) => {
            
            //1.调用h 函数把组件变虚拟dom VNode
            const VNode = h(Alert, {message});
            //这里很关键！！ 串联起了上下文 不然在Alert 里面无法使用 我们的其他插件组件
            VNode.appContext = app._context;
            //2.准备挂载节点
            const container = document.createElement('div');
            //渲染到app节点下面
            document.getElementById("app")?.appendChild(container);
            //3.渲染虚拟dom 节点到真实 dom
            render(VNode, container);
        }
    }
}
```

再次测试

![](/v3/3.png)

成功！

### 添加 `$alert()` 类型提示

我们可以定义一个 `hooks` 去获取 `proxy` 对象， 并且添加 `$alert`的类型声明

```ts
import { ComponentInternalInstance, getCurrentInstance } from "vue";
import type { ComponentPublicInstance } from "vue";

type MyComponentPublicInstance = ComponentPublicInstance & {
  //全局alert 方法
  $alert: (message: string) => null
}

export default function useCurrentInstanceProxy() {

    const proxys = (getCurrentInstance() as ComponentInternalInstance).proxy;
    let proxy = proxys as MyComponentPublicInstance
    return {
        proxy
    };
}

```
这样我们再修改之前 使用 `$alert` 的地方 这样就不用写 `(proxy as any)` 了

```vue
<template>
  <div v-if="loggin">Weclome {{user.username}}</div>
  <div v-if="!loggin">please login</div>
  <button @click="test">Test</button>
</template>

<script lang='ts' setup>
import { useUser } from '../composables/useUser';
import useCurrentInstanceProxy from '../composables/useCurrentInstanceProxy';

const { proxy } = useCurrentInstanceProxy();
const test = () => {
  proxy && proxy.$alert("dsdds")
}

const { user, loggin } = useUser();

</script>
```

OK 这样我们的简单的弹窗插件就完成了