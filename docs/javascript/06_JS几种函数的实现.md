# JS 中几种常见方法和知识的实现

## 1. new 

`new` 生成新对象 操作主要进行以下操作

- 1. 创建一个全新的对象 将这个对象的原型指向构造函数的原型对象
- 2. 将新创建的对象绑定为构造函数的this 运行构造函数
- 3. 判断函数返回值是否是一个对象切不为空 是的话 返回此值 否则返回之前创建的新的对象 

```js
/**
 * 
 * @param {function} func 
 * @returns object
 */
function myNew(func) {
    
    let obj = {};
    //提取传入的参数
    let args = Array.prototype.slice.call(arguments, 1);
    //设置原型 将新创建的对象__proto__指向 函数的原型对象
    Object.setPrototypeOf(obj, func.prototype);
    //将obj传入执行func 
    const res = func.apply(obj, args);
    //判断res 返回值 是否是对象 且 不为空
    if(typeof res === 'function' || (typeof res == 'object' && res != null)) {
        return res;
    }
    return obj;
}
```
## 2. bind

`bind` 主要是运用了闭包。`bind` 中 将`fn`绑定`context`并且放在返回函数中执行。

- 这里注意 `new` 的优先级是比 `bind` 高的，所以需要特殊处理。

```js
Function.prototype.myBind = function(context) {
    const fn = this;
    const args = Array.prototype.slice.call(arguments, 1);

    const newFunc = function() {
        const newArgs = args.concat(...Array.from(arguments));
        //new newFunc 调用时 绑定this
        if(this instanceof newFunc) {
            fn.apply(this, newArgs);
        } else {
            //普通调用时 绑定context
            fn.apply(context, args);
        }
    }
    //支持 new 调用
    newFunc.prototype = Object.create(fn.prototype);

    return newFunc;
}
```

## 3. call

主要是借助 `对象.函数` 实现函数`this`指向的改变, 为了防止临时生成的属性名和绑定对象的冲突，我们可以借助`Symbol`

```js
Function.prototype.MyCall = function(context) {
    
    const fn = this;
    //生成一个唯一性的key属性  防止和其他变量冲突
    const key = Symbol('key');
    //将函数绑定在context 上 借助对象调用函数 实现 this 改变
    context[key] = fn;
    const args = Array.from(arguments).slice(1);

    let res = context[key](...args);
    //执行完成 之后删除 之前临时的key
    delete context[key];

    return res;
}
```

## 4. deepCopy 

实现深拷贝。 主要是注意循环引用，还有数组、`Map`、`Set`等的不同处理。

```js
function deepCopy(obj, cache = new WeakMap()) {
    //如果不是对象 直接返回
    if(obj instanceof Object) return obj;
    //是否已存在 防止循环引用问题
    if(cache.get(obj)) return cache.get(obj);
    //支持深拷贝函数
    if(obj instanceof Function) {
        return function() {
            obj.apply(this, arguments);
        }
    }
    //是否是对象 还是 数组
    const res = Array.isArray(obj) ? [] : {};
    //Date 
    if(obj instanceof Date) return new Date(obj);
    //正则
    if(obj instanceof RegExp) return new RegExp(obj.source, obj.flags);
    //Map
    if(obj instanceof Map) {
        res = new Map();
        for(const [key, value] of obj.entries()) {
            res.set(key, deepCopy(value));
        }
        return res;
    }
    //Set
    if(obj instanceof Set) {
        res = new Set();
        for(const value of obj.values()) {
            res.add(deepCopy(value));
        }
        return res;
    }
    //放入缓存
    cache.set(obj, res);
    //对象还是数组 直接遍历所有键值
    Object.keys(obj).forEach(key => {
        if(obj[key] instanceof Object) {
            res[key] = deepCopy(obj[key], cache);
        } else {
            res[key] = obj[key];
        }
    })

    return res;
} 
```
## 5. 事件总线

主要是利用发布订阅模式

```js
class EventBus {

    constructor() {
        this.cache = {}
    }
    //触发事件
    emit(name, args){
        let tasks = this.cache[name] || [];
        //防止事件内重复注册监听事件 导致死循环
        tasks = tasks.slice();
        tasks.forEach(task => {
            task(args);
        })
    }
    //注册事件监听回调
    on(name, fn) {
        let tasks = this.cache[name] || [];

        tasks.push(fn);
        this.cache = tasks;
    }
    //注销事件监听回调
    off(name, fn) {
        let tasks = this.cache[name] || [];

        let index = tasks.findIndex(fns => fns === fn);

        if(index > -1) tasks.splice(index, 1);
    }
}
```

## 6. 柯里化

只传递给函数一部分参数来调用它，让他返回一个函数去处理剩下的参数

```js

function curry(func) {

    return function curried(...args) {
        //利用func.length 判断方法实际要求的参数 arguments 则表示实际传递的参数
        if(args.length >= func.length) {
            return func.apply(this, args);
        }

        return function(...args2) {
            return curried.apply(this, [...args, ...args2]);
        }
    }
}

```

## 7. 数组扁平化

将数组中的数组扁平化 并且 可以设置 展开 的层级

```js
function myFlat(arr, index = -1) {

   if(index < 0) {
        return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? myFlat(cur, -1): cur) , [])
   }

   if(index > 0) {
       return arr.reduce((pre, cur) => pre.concat(Array.isArray(cur) ? myFlat(cur, index - 1) : cur) , [])
   }

   return arr;
}

```

