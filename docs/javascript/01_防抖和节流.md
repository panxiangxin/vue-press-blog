# 防抖和节流的实现

## 函数防抖

### 原理

当持续触发一个事件时，在定义的响应时间 `t` 内，事件没有再次触发，此时才会执行回调，如果 `t` 时间内，又触发了事件，则重新计时。

### 应用场景

-   1. `search` 远程搜索框：防止用户不断输入工程中，不断请求资源，只响应用户输入完成之后的事件。节约服务器资源。
-   2. 各种按钮提交 或者 查询场景
-   3. 监听 `resize` 触发，不断的调整浏览器窗口大小会不断触发 `resize`，使用防抖可以只执行最后一次。

### 代码实现

```javascript
/**
 *
 * @param {function} func 回调函数
 * @param {number} delay 延迟时间
 * @param {boolean} immediated 是否第一次触发立即调用
 * @returns
 */
const debounced = function (func, delay, immediated) {
    let timer

    return function () {
        let context = this
        let args = Array.prototype.slice.apply(arguments)

        if (timer) clearTimeout(timer)

        if (immdiated) {
            var t = !timer
            //第一次触发之后 间隔delay 不触发之后才能再次触发
            timer = setTimeout(function () {
                timer = null
            }, delay)

            if (t) {
                func.apply(context, args)
            }
        } else {
            timer = setTimeout(function () {
                func.apply(context, args)
                timer = null
            }, delay)
        }
    }
}
```

## 函数节流

### 原理

当频繁触发一个事件，每隔设置的间隔时间，回调函数只会触发一次。

### 应用场景

-   1. 拖拽场景，固定时间内只触发一次，防止高频率触发变动位置
-   2. 监听滚动事件， 实现触底加载更多功能
-   3. 抢票或者之类的 多次点击 `mousedown` `keydown` 事件

```javascript
function throttle = (func, delay) {
    let args;
    let lastTime = 0;

    return function() {
        //获取当前时间
        const currentTime = new Date().getTime();
        args = Array.prototype.slice.apply(arguments);
        if(currentTime - lastTime > delay) {
            func.apply(this, args);
            lastTime = currentTime;
        }
    }
}
```
