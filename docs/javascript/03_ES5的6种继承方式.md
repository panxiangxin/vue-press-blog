# ES5 的 6 种继承方式

## 1. 原型链继承

构造函数、原型和实例之间的关系： 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。

继承本质就是复制，即重写原型对象，代之一个新类型的对象。

```javascript
function Person() {
    this.name = 'Person'
    this.colors = ['white', 'yellow', 'black']
}

Person.prototype.type = 'animal'

Person.prototype.say = function () {
    console.log(this.name)
}

function Man() {
    this.name = 'Man'
}

Man.prototype = new Person()

let man = new Man()
let man2 = new Man()

man.colors.push('xxx')

console.log(man.colors, man2.colors)
//['white', 'yellow', 'black'，'xxx'],
//['white', 'yellow', 'black'，'xxx']
```

::: warning 缺点
会导致多个实例会共享同一个原型对象 共享同一个内存空间 导致篡改
:::

## 2. 借用构造函数继承

使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）

```javascript
function Person() {
    this.name = 'Person'
    this.colors = ['white', 'yellow', 'black']
}

Person.prototype.type = 'animal'

Person.prototype.say = function () {
    console.log(this.name)
}

function Man() {
    Person.call(this)
    this.name = 'Man'
}

let man = new Man()

console.log(man)

console.log(man.say()) // man.say is not a function
```

::: warning 缺点

-   1.只能继承父类实例属性和方法，不能继承原型属性和方法
-   2.无法实现复用， 每一个子类都有父类函数实例副本 影响性能
:::

## 3. 组合式继承

组合式继承 就是结合 原型链继承 和 借用构造函数继承 避免了共享同一原型对象 和 无法调用父原型对象方法问题。

```javascript
function Person() {
    this.name = 'Person'
    this.colors = ['white', 'yellow', 'black']
}

Person.prototype.type = 'animal'

Person.prototype.say = function () {
    console.log(this.name)
}

function Man() {
    //第二次调用 Person
    Person.call(this)
    this.name = 'Man'
}
//第一次调用Person
Man.prototype = new Person()
//修复 Man 原型上的构造函数指向
Man.prototype.constructor = Man

let man = new Man()
let man2 = new Man()

man.colors.push('ddd')

console.log(man.colors, man2.colors) //没有互相影响
console.log(man.say()) //正常输出 Man
```

::: warning 缺点

-   1.第一次调用 `Person()` `Man.prototype` 添加了 `name`, `color` 属性。
-   2.第二次调用 `Person()` 给 `man` 写入两个属性 `name`, `age`;
-   3.两次调用 `Person` 方法 造成额外开销。

:::

## 4. 原型式继承

利用一个空对象作为媒介，将某个对象直接赋值给空对象构造函数的原型。

```javascript
function object(obj) {
    function F() {}
    F.prototype = obj
    return new F()
}
//object 对传入其中的对象做了一次浅复制
//将构造函数F的原型直接指向了传入原型对象
var person = {
    name: 'dede',
    friends: ['a', 'b', 'c', 'd'],
    getName() {
        return this.name
    }
}

var anotherPerson = object(person)
anotherPerson.name = 'adr'
anotherPerson.friends.push('adr')

var yetPerson = object(person)
yetPerson.name = 'yet'
yetPerson.friends.push('yet')

console.log(anotherPerson.friends, yetPerson.friends)

//['a', 'b', 'c', 'd','adr', 'yet'],
//['a', 'b', 'c', 'd','adr', 'yet']
//互相影响
```

::: warning 缺点

-   原型链继承多个实例的引用类型属性指向相同，存在篡改可能
-   无法传递参数

:::


## 5. 寄生式继承

在原型式继承基础上，增强对象， 返回构造函数 缺点如原型式继承

```javascript
function object(obj) {
    function F() {}
    F.prototype = obj
    return new F()
}

function createAnother(original) {
    var clone = object(original)
    clone.say = function () {
        console.log('hi')
    }
    return clone
}
```

函数的主要作用是 为构造函数新增属性和方法 以增强函数.

```javascript
var person = {
    name: 'dede',
    friends: ['a', 'b', 'c', 'd']
}

var anothers = createAnother(person)
anothers.say() // hi
```

## 6. 寄生组合式继承

组合借用构造函数传递参数 和 寄生模式实现继承 

::: tip 

只调用了一次 `Person()`构造方法，并且避免了在 `Man.prototype` 创建多余、不必要的属性。于此同时，原型链还能保持不变。能够正常使用 `instanceof` 和 `isPrototypeOf` 方法。
这是最成熟 也是现在库实现的方法

:::
```javascript
function Person() {
    this.name = 'Person'
    this.colors = ['white', 'yellow', 'black']
}

Person.prototype.type = 'animal'

Person.prototype.say = function () {
    console.log(this.name)
}

function Man(age) {
    //借用父类构造函数 增强子类的实例属性 支持穿参和避免篡改
    Person.call(this)
    this.age = age
}

function extendsPrototype(parent, children) {
    //创建对象  创建父原型对象的副本
    var prototype = Object.create(parent.prototype)
    //增强对象 弥补因重写原型而失去默认的constructor 正确指向
    prototype.constructor = children
    //指定对象 将新创建的对象赋值给子类原型
    children.prototype = prototype
}

extendsPrototype(Person, Man)
//子类原型对象 添加方法
Man.prototype.ages = function () {
    console.log(this.age)
}

let man = new Man(18)
let man1 = new Man(22)

man.colors.push('xxx')
man1.colors.push('xxxx')

console.log(man, man1)
```
