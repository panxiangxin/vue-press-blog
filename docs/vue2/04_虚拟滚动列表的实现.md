# 虚拟滚动列表的实现

在大屏项目中设计到了大数据量的表格自动滚动问题，如果按照之前的方案全部加载数据渲染表格然后去滚动表格的话，页面会出现卡顿，也由于在项目中和滚动表格在同一页面的还有几个较大的`webp动画`，所以非常消耗CPU资源，导致该页面渲染卡顿。所以为了解决这个问题，这个表格最好采用`虚拟滚动 + 自动滚动`。节省表格dom节点的渲染，并且支持大数据量。

## 1. 搭建mock数据环境

为了造数方便，这里我们搭建一个简易的`mock server`。 在 `src/mock`创建 `server.js`, 记得提前安装 `mockjs` 和 `express` 依赖

```sh
pnpm i express mockjs -D
```

```js
const Mock = require("mockjs");
const express = require("express");

const app = express();

function generatorCardList(num) {
  return Mock.mock({
    [`list|${num}`]: [
      {
        "id|+1": 1,
        title: "@ctitle(5,10)",
        content: "@ctitle(10, 20)",
      },
    ],
  });
}

/*为app添加中间件处理跨域请求*/
app.use(function (req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "*");
  res.header("Content-Type", "application/json;charset=utf-8");
  res.header("Access-Control-Allow-Methods", "PUT, POST, GET, DELETE, OPTIONS");
  next();
});

app.get("/card", function (req, res) {
  const { num } = req.query;
  res.json(generatorCardList(num));
});

app.listen(4000, () => {
  console.log("启动模拟数据服务http://localhost:4000/card?num=100");
});
```
可以在 `package.json` 中 添加 对应 `script`

```json
"server": "node src/mock/server.js"
```

## 2.实现虚拟滚动

![](/xngd/xngd.png)

根据图中我们可以看到，无论我们如何滚动，我们可视区域的大小其实是不变的，那么要做到性能最大化就需要尽量少地渲染 `DOM` 元素，而这个最小值也就是可视范围内需要展示的内容，也就是图中的绿色区块，在可视区域之外的元素均可以不做渲染。

那么问题就来了，如何计算可视区域内需要渲染的元素，我们通过如下几步来实现虚拟滚动：

- 我们设置每一行的高度相同，方便计算
- 需要得知渲染的数据量（数组长度），可基于总量和每个元素的高度计算出容器整体的所需高度，这样就可以伪造一个真实的滚动条
- 获取可视区域的高度
- 在滚动事件触发后，滚动条的距顶距离也可以理解为这个数据量中的偏移量，再根据可视区域本身的高度，算出本次偏移的截止量，这样就得到了需要渲染的具体数据

html 模板

```vue
<template>
<!-- 虚拟滚动容器 -->
  <div
    class="virtual-list-container"
    @scroll.passive="handleScrollEvent($event)"
    ref="container"
  >
  <!-- 滚动列表容器 -->
    <div :style="transformStyle" ref="lists">
      <div class="card" v-for="item in showList" :key="item.id">
        <div class="title">{{ item.title }}</div>
        <div class="content">{{ item.content }}</div>
      </div>
    </div>
  </div>
</template>
<style lang="scss" scoped>
.virtual-list-container {
//这里要设置overflow: auto; scroll 才能监听到滚动距离
  overflow: auto;
  position: relative;
  height: 100%;

  .card {
    padding: 10px;
    border: 1px solid #000;
    box-shadow: 1px 5px 20px -10px #000;
    .title {
      color: #c7b6b6;
    }

    .content {
      color: #333;
    }
  }
}
</style>
```
这里我们使用container的大小作为我们的容器大小。`@scroll.passive`监听容器滚动事件 `.passive`意思是有节流效果，一段时间触发一次。注意这里设置 `overflow: auto`。

`transformStyle`这个样式是设置具体列表的 `paddingTop` 和 `paddingBottom` 防止渲染抖动和模拟一个真实的滚动条。

下面我们来写具体的逻辑代码

```vue
<script>
export default {
  data() {
    //这里存放数据
    return {
      //所有列表数据
      list: [],
      //单行高度
      itemHeight: 64,
      //容器高度
      containerHeight: 0,
      //滚动距离
      scrollTop: 0,
    };
  },
  //监听属性 类似于data概念
  computed: {
    //显示区域的第一个元素位于数组的位置
    startIndex() {
      return ~~(this.scrollTop / this.itemHeight);
    },
    //显示区域的最后的元素位于数组的位置 这里注意判断起始位置加最大渲染个数之和和数组最大长度的大小 取两者之间最小值
    endIndex() {
      return Math.min(
        this.startIndex + this.containerSize,
        this.list.length - 1
      );
    },
    //容器渲染最大行数 这里 + 2 是防止向上滚动一点 此时列表可能会出现额外的上面一条 和 下面一条 所以需要 + 2
    containerSize() {
      return ~~(this.containerHeight / this.itemHeight) + 2;
    },
    //具体渲染列表数据
    showList() {
      return this.list.slice(this.startIndex, this.endIndex + 1);
    },
    //虚拟列表 填充的paddingTop 和 paddingBottom 设置此时滚动列表真实位置 模拟真实滚动
    transformStyle() {
      return {
        paddingTop: this.startIndex * this.itemHeight + "px",
        paddingBottom:
          (this.list.length - this.endIndex - 1) * this.itemHeight + "px",
      };
    },
  },
  //监控data中的数据变化
  watch: {},
  //方法集合
  methods: {
    handleScrollEvent() {
      //获得此时 容器的高度
      this.containerHeight = this.$refs.container.offsetHeight;
      //获得此时容器滚动的距离
      this.scrollTop = this.$refs.container.scrollTop;
    },
    //获取模拟数据
    getListData(num) {
      this.$axios.get(`http://localhost:4000/card?num=${num}`).then((res) => {
        this.list = res.data.list;
      });
    },
  },

  created() {
    //渲染数据
    this.getListData(1120);
  },
  
  mounted() {
    //加载滚动事件
    this.handleScrollEvent();
  },
};
</script>
```

这样我们就简单实现了一个虚拟滚动的列表了。

## 3.添加自动滚动功能

其实就是设置定时设置容器的滚动距离 `scrollTop` 模拟向上滚动效果。 这里我们用 `requestAnimationFrame` 实现更加自然的过渡。

所有的具体代码如下：

```vue
<template>
<!-- 虚拟滚动容器 -->
  <div
    class="virtual-list-container"
    @scroll.passive="handleScrollEvent($event)"
    ref="container"
    @mouseenter="enter"
    @mouseleave="leave"
  >
  <!-- 滚动列表容器 -->
    <div :style="transformStyle" ref="lists">
      <div class="card" v-for="item in showList" :key="item.id">
        <div class="title">{{ item.title }}</div>
        <div class="content">{{ item.content }}</div>
      </div>
    </div>
  </div>
</template>

<script>
let timer;

export default {
 
  data() {
    //这里存放数据
    return {
      //所有列表数据
      list: [],
      //单行高度
      itemHeight: 64,
      //容器高度
      containerHeight: 0,
      //滚动距离
      scrollTop: 0,
    }
  },
  //监听属性 类似于data概念
  computed: {
    //显示区域的第一个元素位于数组的位置
    startIndex() {
      return ~~(this.scrollTop / this.itemHeight);
    },
    //显示区域的最后的元素位于数组的位置 这里注意判断起始位置加最大渲染个数之和和数组最大长度的大小 取两者之间最小值
    endIndex() {
      return Math.min(
        this.startIndex + this.containerSize,
        this.list.length - 1
      );
    },
    //容器渲染最大行数 这里 + 2 是防止向上滚动一点 此时列表可能会出现额外的上面一条 和 下面一条 所以需要 + 2
    containerSize() {
      return ~~(this.containerHeight / this.itemHeight) + 2;
    },
    //具体渲染列表数据
    showList() {
      return this.list.slice(this.startIndex, this.endIndex + 1);
    },
    //虚拟列表 填充的paddingTop 和 paddingBottom 设置此时滚动列表真实位置 模拟真实滚动
    transformStyle() {
      return {
        paddingTop: this.startIndex * this.itemHeight + "px",
        paddingBottom:
          (this.list.length - this.endIndex - 1) * this.itemHeight + "px",
      };
    },
  },
  //方法集合
  methods: {
    //鼠标移入暂停滚动
    enter() {
      timer && cancelAnimationFrame(timer);
    },
    //离开重新开始滚动
    leave() {
      this.intervalScroll();
    },
    //滚动条滚动处理
    handleScrollEvent() {
      this.containerHeight = this.$refs.container.offsetHeight;
      this.scrollTop = this.$refs.container.scrollTop;
    },
    //设置自动滚动处理
    intervalScroll() {
      let me = this;
      //判断此时 是否已经滚动到底部 底部自动重新滚动
      if (me.containerHeight + me.scrollTop === me.$refs.lists.offsetHeight) {
        me.$refs.container.scrollTop = 0;
      } else {
        me.$refs.container.scrollTop += 1;
      }

      timer = requestAnimationFrame(this.intervalScroll);
    },
    //获取数据
    getListData(num) {
      this.$axios.get(`http://localhost:4000/card?num=${num}`).then((res) => {
        this.list = res.data.list;
      });
    },
  },

  created() {
    this.getListData(1120);
  },
  beforeDestroy() {
    //离开销毁相应事件
    timer && cancelAnimationFrame(timer);
  },
  mounted() {
    this.handleScrollEvent();
    this.intervalScroll();
  },
};
</script>
<style lang="scss" scoped>

.virtual-list-container {
  overflow: auto;
  position: relative;
  height: 100%;

  .card {
    padding: 10px;
    border: 1px solid #000;
    box-shadow: 1px 5px 20px -10px #000;
    .title {
      color: #c7b6b6;
    }

    .content {
      color: #333;
    }
  }
  &::-webkit-scrollbar {
    width: 0px;
  }
}
</style>
```

![](/xngd/scroll.gif)

OK 完成